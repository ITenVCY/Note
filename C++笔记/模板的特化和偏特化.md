## 模板特化

##### 函数模板特化

> 解决开发过程中由于要对特殊类型做特殊的处理, 不能直接使用函数模板,例如,当我们判断两个值是否相等的时候, 普通的变量和字符串或者类的比较就需要单独特化,来做相应的处理.



```c++
template <typename T>
bool isEqual(T va1,T va2)
{
    return va1 == va2 ? true : flase;
}

//特化
template <> //不需要添加类型模板, 省略或者加上空格即可
bool isEqual<string>(string& va1,string& va2)
{
    return strcmp(va1.c_str(),va2.c_str());
}

//匹配时优先匹配特化函数
```

```c++
#include <iostream>
#include <string>
#include <cstdlib>
#include <cstring>

using namespace std;
class F
{
public:
        F(int fz,int fm):m_fz(fz),m_fm(fm) {}
        operator int() const 
        {
                return (double)m_fz/m_fm;

        }
private:
        int m_fz;
        int m_fm;
};



template <typename T>
struct hash
{
        void operator()(T i) 
        {
                cout << "hash" << endl;
        }
};

template <>
struct hash<int>
{
        void operator()(int i) 
        {
                cout << "hash<int>" << endl;
        }
};

template<typename T>
void is(T v1)
{
        cout << "template<type T>"<<endl;       
}

template<>
void is<int>(int v1)
{
        cout << "template<int>"<<endl;  
}

void is(int va1)
{
        cout << "is" << endl;
}


int main()
{
        hash<int>()(100);//特化类
        is(2); //测试可知调用顺序的优先级, 不带模板 >  特化模板 > 函数模板

        return 0;
}

```





##### 类模板特化



###### 全特化

> 将所有模板类型都进行特化

```c++
template <typename T1,typename T2>
class Test
{
    
};

//全特化
template <>
class Test<int,char>
{

};

```

###### 偏特化

> 对于模板的类型做一些限制

1. 部分偏特化

```c++
//只对函数模板的一部分模板类型进行特化
template <typename T1,typename T2>
class Test
{
    
};

//部分偏特化
template <typename T1>//此处只写未特化的类型
class Test<typename T1,char>
{

};
```

2. 对类型的范围的限制, 主要的类型基础不变

```c++
template <class T1, class T2>
class Test2{
}

//对模板类型的范围做出一定的限制
template <class T1 , class T2 >  //此处只需写未进行特化的模板类型
class Test2<T1* , T2*>{
}

Test2<string*,string*> t2;
```

###### 模板模板参数

```c++
template <typename T,
		 template <typename T>
			class Container
		>
class Xcls
{
    Container<T> c;
}
//调用
template <typename T>
using Lst = list<T,allocator<T>>;

Xcls<string,Lst> myLs;
```

