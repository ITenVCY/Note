## 单例模式

```c++
#include <iostream>
#include <thread>
#include <vector>
#include <list>
#include <mutex>

using namespace std;


mutex myMutex;

class MyClass
{
public:
	static MyClass* instance;
	static MyClass* GetInstance()//返回必须要加static
	{
        /*
        	如果 if(!instance)条件不成立,则一定代表instance已经被new过反之,不带代表一定没有被new过, 在多线程中如果不加双重锁定,那么其余的调用每次都要加锁,严重影响了效率,
        */
        if(!instance) //双重锁定(双重检查)
        {
            myMutex.lock();
            if (!instance)
            {
                instance = new MyClass();
                static AutoDelete autoDeleteGlob; //引入静态对象自动delete单例
            }
            myMutex.unlock();
        }

		return instance;
	}
	class AutoDelete
	{
	public:
		~AutoDelete()
		{
			if (instance)
			{
				delete instance;
				instance = nullptr;
			}
		}
	};
	void print()
	{
		cout << "这里是单例模式" << endl;
	}
private:
	MyClass()
	{
	}
};

//静态变量初始化
MyClass *MyClass::instance = NULL;

int main()
{
	MyClass* pa = MyClass::GetInstance();
	pa->print();

	return 0;
}
/*
	1. 为什么不在外面类中析构, 如果在类中析构会导致一个问题, 在当前调用一次,结束后如果析构那么会导致第二次调用再次创建, 失去意义.
	2. 在调用多线程之前先初始化单例和数据.只读数据对多线程访问不存在影响 
*/
```

```c++
/*
	为什么不用一个if解决的原因
*/
#include <iostream>
#include <thread>
#include <vector>
#include <list>
#include <mutex>

using namespace std;


mutex myMutex;

class MyClass
{
public:
	static MyClass* instance;
	static MyClass* GetInstance()//返回必须要加static
	{
		if (!instance)
		{
			myMutex.lock();

			instance = new MyClass();
			static AutoDelete autoDeleteGlob; //引入静态对象自动delete单例

			myMutex.unlock();
		}

		return instance;
	}
	class AutoDelete
	{
	public:
		~AutoDelete()
		{
			if (instance)
			{
				delete instance;
				instance = nullptr;
			}
		}
	};
	void print()
	{
		cout << "这里是单例模式" << endl;
	}
private:
	MyClass()
	{
		cout << "构造函数 my class " << endl;
	}
	~MyClass()
	{
		cout << "析构函数" << endl;
	}
};

//静态变量初始化
MyClass *MyClass::instance = NULL;

void func()
{
	MyClass::GetInstance();
}

int main()
{
	vector<thread> thr;
	for (int i = 0; i < 10; ++i)
	{
		thr.push_back(thread(func));
	}


	for (auto it = thr.begin(); it != thr.end(); ++it)
	{
		it->join();
	}

	return 0;
}
/*
	输出结果:
构造函数 my class
构造函数 my class
构造函数 my class
构造函数 my class
构造函数 my class
构造函数 my class
构造函数 my class
构造函数 my class
析构函数
请按任意键继续. . .
多次new但是没有delete资源
*/
```
