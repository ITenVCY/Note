##### 查询当前编译器C++版本

```c++
    //C99
__cplusplus = 199711L
	//C11
__cplusplus = 201103L
```



## call_once()

> 能够保障某个函数只执行一次,`call_once`具备互斥功能, 比互斥的资源消耗更小, 需要配合`std::once_flag`使用, 调用一次完成后`once_flag`就会被置位,下次再次调用就不会被调用

```c++
#include <iostream>
#include <thread>
#include <vector>
#include <list>
#include <mutex>

using namespace std;

once_flag flag;

mutex myMutex;



class MyClass
{
public:
	static MyClass* instance;

	static void Create()
	{
		instance = new MyClass();
		cout << "执行次数" << endl;
		static AutoDelete autoDeleteGlob; //引入静态对象自动delete单例
	}

	static MyClass* GetInstance()//返回必须要加static
	{
        if(!instance)
        {
            call_once(flag,Create);//可以保证某个函数只执行一次,而且具备锁功能
        }

		return instance;
	}

	class AutoDelete
	{
	public:
		~AutoDelete()
		{
			if (instance)
			{
				delete instance;
				instance = nullptr;
			}
		}
	};
	void print()
	{
		cout << "这里是单例模式" << endl;
	}
private:
	MyClass()
	{
		cout << "构造函数 my class " << endl;
	}
	~MyClass()
	{
		cout << "析构函数" << endl;
	}
};

//静态变量初始化
MyClass *MyClass::instance = NULL;

void func()
{
	MyClass::GetInstance();
}

int main()
{
	vector<thread> thr;
	for (int i = 0; i < 10; ++i)
	{
		thr.push_back(thread(func));
	}


	for (auto it = thr.begin(); it != thr.end(); ++it)
	{
		it->join();
	}

	return 0;
}
/*
	输出:
构造函数 my class
执行次数
析构函数
请按任意键继续. . .
*/
```

## 条件变量

> 若一个线程需要另一个线程条件满足才能执行

##### std::condition_variable

> 等待某一个条件达成,配合互斥量工作



## 创建后台任务



#### std::anyc

> 函数模板, 启动一个异步任务



## 引用的假象

```c++
int a = 2;
int &r = a;
sizeof(a) == sizeof(r); //true, 假象一
&a == &r;//true, 假象二

```



