```python
>>>def divide(x, y):
        try:
            result = x / y
        except ZeroDivisionError:#除数为0抛出异常
            print("division by zero!")
        else:#如果try语句没有抛出异常那么执行
            print("result is", result)
        finally:#无论是否抛出异常都执行.   清理行为
            print("executing finally clause")
   
>>> divide(2, 1)
result is 2.0
executing finally clause
>>> divide(2, 0)
division by zero!
executing finally clause
>>> divide("2", "1")
executing finally clause
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'
```

##### 预定义清理行为

```python
for line in open("myfile.txt"):
    print(line, end="")
    
 #以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:
with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
```

##### with 的神奇魔法

```python
#对比没有with 的版本
# 此处没有对文件没有的情况分析, 抛出异常程序崩溃
f = open(r'c:\test.txt', 'r')
data = f.read()
f.close()

#采用try except
try:
    	f = openr(r'c:\test.txt', 'r')
except OSError as err:
    	print("1")
except:
    	raise  #不处理整个异常, 向上再次抛出
else:
    	print("这里是else")#没有异常会执行
finally:
    	f.close() #无论如何都会执行,

    
#with的优雅写法

with open(r'c:\test.txt', 'r') as f:
    data = f.read()
    
""" with后面接的对象返回的结果赋值给f。此例当中open函数返回的文件对象赋值给了f.with会自已获取上下文件的异常信息。
with是如何做到的呢？
with后面返回的对象要求必须两__enter__()/__exit__()这两个方法


object.__enter__(self)
进入与此对象相关的运行时上下文。with语句将将此方法的返回值绑定到语句的AS子句中指定的目标（如果有设置的话）
 
object.__exit__(self, exc_type, exc_value, traceback)
退出与此对象相关的运行时上下文。参数描述导致上下文退出的异常。如果上下文运行时没有异常发生，那么三个参数都将置为None。
如果有异常发生，并且该方法希望抑制异常（即阻止它被传播），则它应该返回True。否则，异常将在退出该方法时正常处理。
 
请注意, __exit__()方法不应该重新抛出传入的异常，这是调用者的职责
"""


```

###### 无异常发生的with

```python

class Test:
    def __enter__(self):
        print('__enter__() is call!')
        return self
 
    def dosomething(self):
        print('dosomethong!')
 
    def __exit__(self, exc_type, exc_value, traceback):
        print('__exit__() is call!')
        print(f'type:{exc_type}')
        print(f'value:{exc_value}')
        print(f'trace:{traceback}')
        print('__exit()__ is call!')
 
with Test() as sample:
    sample.dosomething()
 
>>
__enter__() is call!
dosomethong!
__exit__() is call!
type:None
value:None
trace:None
__exit()__ is call!


"""
	以上的实例Text,我们注意到他带有__enter__()/__exit__()这两个方法，当对象被实例化时，就会主动调用__enter__()方法，任务执行完成后就会调用__exit__()方法，另外，注意到，__exit__()方法是带有三个参数的(exc_type, exc_value, traceback), 依据上面的官方说明：如果上下文运行时没有异常发生，那么三个参数都将置为None, 这里三个参数由于没有发生异常，的确是置为了None, 与预期一致.

"""
```

###### 有异常发生的例子

```python

class Test:
    def __enter__(self):
        print('__enter__() is call!')
        return self
 
    def dosomething(self):
        x = 1/0
        print('dosomethong!')
 
    def __exit__(self, exc_type, exc_value, traceback):
        print('__exit__() is call!')
        print(f'type:{exc_type}')
        print(f'value:{exc_value}')
        print(f'trace:{traceback}')
        print('__exit()__ is call!')
        # return True
 
 
with Test() as sample:
    sample.dosomething()
>>
__enter__() is call!
Traceback (most recent call last):
__exit__() is call!
type:<class 'ZeroDivisionError'>
  File "C:/Users/xxx/PycharmProjects/Test1/test.py", line 23, in <module>
value:division by zero
    sample.dosomething()
trace:<traceback object at 0x000001C08CF32F88>
  File "C:/Users/xxx/PycharmProjects/Test1/test.py", line 10, in dosomething
__exit()__ is call!
    x = 1/0
ZeroDivisionError: division by zero

    
    """
    从结果可以看出, 在执行到dosomethong时就发生了异常，然后将异常传给了__exit__(), 依据上面的官方说明：如果有异常发生，并且该方法希望抑制异常（即阻止它被传播），则它应该返回True。否则，异常将在退出该方法时正常处理。当前__exit__并没有写明返回True，故会抛出异常，也是合理的，但是正常来讲，程序应该是不希望它抛出异常的，这也是调用者的职责，我们将再次修改__exit__, 将其返回设置为True, 
    """
```

###### 有异常但是不抛出

```python

class Test:
    def __enter__(self):
        print('__enter__() is call!')
        return self
 
    def dosomething(self):
        x = 1/0
        print('dosomethong!')
 
    def __exit__(self, exc_type, exc_value, traceback):
        print('__exit__() is call!')
        print(f'type:{exc_type}')
        print(f'value:{exc_value}')
        print(f'trace:{traceback}')
        print('__exit()__ is call!')
        return True
 
 
with Test() as sample:
    sample.dosomething()
 
>>
__enter__() is call!
__exit__() is call!
type:<class 'ZeroDivisionError'>
value:division by zero
trace:<traceback object at 0x000001C94E592F88>
__exit()__ is call!


"""
	异常被抑制
"""
```

