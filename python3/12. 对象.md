##### 多态

> **一类事物具有多种形态,  例如动物的形态可以有狗,猪等**

```python
class Animal:
	def run(self):
		raise AttributeError('子类必须实现这个方法') 

class Dog(Animal):
	def run(self):
		print("dog runing!")

class Pig(Animal):
	def run(self):
		print("pig runing!")

class Tes(Animal):
	def runing(self):
		print("Tes !")

t1 = Tes()
t1.runing()
t1.run() #子类继承父类方法, 但是未实现run方法, 最后会调用父类run方法, 导致抛出自定义异常


dog = Dog()
dog.run() #调用子类方法


pig = Pig()
pig.run()#调用子类方法

```

##### 抽象基类

```python
import abc

class Animal(metaclass = abc.ABCMeta):
	@abc.abstractmethod  #子类继承则必须实现
	def run(self):
		pass

class Dog(Animal):
	def run(self):
		print("dog runing!")

class Pig(Animal):
	def run(self):
		print("pig runing!")

class Tes(Animal):
	def run1(self):
		print("Tes !")

t1 = Tes()

#输出
Traceback (most recent call last):
  File "1.py", line 20, in <module>
    t1 = Tes()
TypeError: Can't instantiate abstract class Tes with abstract methods run

    
    #修改Tes中run1() -> run()即可

        
```

##### 多态性

> **多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数**

```python
import abc

class Animal(metaclass = abc.ABCMeta):
	@abc.abstractmethod
	def run(self):
		pass

class Dog(Animal):
	def run(self):
		print("dog runing!")

class Pig(Animal):
	def run(self):
		print("pig runing!")

class Tes(Animal):
	def run1(self):
		print("Tes !")


def run(obj):
	obj.run()


dog = Dog()
pig = Pig()

#输出
run(dog)
run(pig)


```

##### 构造函数和析构函数

```python
import abc

class Animal(metaclass = abc.ABCMeta):
	def __init__(self,name):
		self.name = name

	@abc.abstractmethod
	def run(self):
		pass

class Dog(Animal):
	def run(self):
		print(self.name,"Dog的构造函数")

dog = Dog("1") #子类没有定义构造函数,使用父类的构造函数
dog.run() #调用子类方法,但是引用了父类对象的name, 默认是公有的



#当实例化一个对象的时候第一个被调用的是__new__()方法, 极少去重写

class CS(str): #继承一个不可改变的对象,
    def __new__(cls,string)
    	string = string.upper()#在转换之前进行替换,
        return str.__new__(cls,string) # 返回的时候调用父类的new
    
    
 # 析构函数, 当所有的引用全部被删除或者释放以后就会
__del__(self)

class C:
    def __init(self)
    	print("init")
    def __del__(self)
    	print("del")
```

##### 公有和私有

```python
#默认公有

>>> class A:
...     __name = "123"  #在函数或者变量前加上__就是私有
...     def getName(self):
...             return self.__name
... 
>>> 
>>> p = A()
>>> p.__name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'A' object has no attribute '__name'
>>> p._A__name #python的伪私有, 因为还是通过别的方式访问
'123'

```

##### 子类重写后调用父类方法

```python
import abc

class Animal(metaclass = abc.ABCMeta):
	def __init__(self,name):
		self.name = name

	@abc.abstractmethod
	def run(self):
		pass

class Dog(Animal):
	def __init__(self,name):
		super().__init__(name)  #重写构造函数, 如果直接调用run会导致name没有定义, 所以要调用父类的构造函数
        #		Animal.__init__(self,name) #两种方法人选一种
	def run(self):
		print(self.name,"Dog的构造函数")


dog = Dog("1")
dog.run()


#改正后输出
1 Dog的构造函数

#没有加初始化父类的时候的输出
Traceback (most recent call last):
  File "1.py", line 33, in <module>
    dog.run()
  File "1.py", line 17, in run
    print(self.name,"Dog的构造函数")
AttributeError: 'Dog' object has no attribute 'name'

```

